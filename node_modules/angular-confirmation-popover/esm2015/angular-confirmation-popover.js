import { Injectable, Component, Directive, Input, Output, EventEmitter, HostListener, ViewContainerRef, ElementRef, Injector, ComponentFactoryResolver, Renderer2, NgModule, InjectionToken } from '@angular/core';
import { Positioning } from 'positioning';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

class ConfirmationPopoverOptions {
    constructor() {
        this.confirmText = 'Confirm';
        this.cancelText = 'Cancel';
        this.confirmButtonType = 'success';
        this.cancelButtonType = 'default';
        this.placement = 'top';
        this.hideConfirmButton = false;
        this.hideCancelButton = false;
        this.popoverClass = '';
        this.appendToBody = false;
        this.reverseButtonOrder = false;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 */
class ConfirmationPopoverWindowOptions extends ConfirmationPopoverOptions {
}
ConfirmationPopoverWindowOptions.decorators = [
    { type: Injectable },
];
/** @nocollapse */
ConfirmationPopoverWindowOptions.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 */
class ConfirmationPopoverWindowComponent {
    /**
     * @param {?} options
     */
    constructor(options) {
        this.options = options;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.options.onAfterViewInit();
    }
}
ConfirmationPopoverWindowComponent.decorators = [
    { type: Component, args: [{
                selector: 'mwl-confirmation-popover-window',
                styles: [
                    `
    .popover {
      display: block;
    }
    .bs-popover-top .arrow, .bs-popover-bottom .arrow {
      left: 50%;
    }
    .bs-popover-left .arrow, .bs-popover-right .arrow {
      top: 50%;
    }
    .btn {
      transition: none;
    }
    .confirm-btns {
      display: flex;
      justify-content: space-around;
    }
    .confirm-btn-container {
      flex-basis: 50%;
    }
    .confirm-btn-container:not(:first-child) {
      margin-left: 4px;
    }
    .confirm-btn-container:not(:last-child) {
      margin-right: 4px;
    }
    .confirm-btns-reversed {
      flex-direction: row-reverse;
    }
    .confirm-btns-reversed .confirm-btn-container:not(:first-child) {
      margin-right: 4px;
      margin-left: 0;
    }
    .confirm-btns-reversed .confirm-btn-container:not(:last-child) {
      margin-right: 0;
      margin-left: 4px;
    }
  `
                ],
                template: `
    <ng-template #defaultTemplate let-options="options">
      <div [ngClass]="[
        'popover',
        options.placement,
        'popover-' + options.placement,
        'bs-popover-' + options.placement,
        options.popoverClass
      ]">
        <div class="popover-arrow arrow"></div>
        <h3 class="popover-title popover-header" [innerHTML]="options.popoverTitle"></h3>
        <div class="popover-content popover-body">
          <p [innerHTML]="options.popoverMessage"></p>
          <div class="confirm-btns" [class.confirm-btns-reversed]="options.reverseButtonOrder">
            <div
              class="confirm-btn-container"
              *ngIf="!options.hideCancelButton">
              <button
                type="button"
                [mwlFocus]="options.focusButton === 'cancel'"
                [class]="'btn btn-block btn-' + options.cancelButtonType"
                (click)="options.onCancel({clickEvent: $event})"
                [innerHtml]="options.cancelText">
              </button>
            </div>
            <div
              class="confirm-btn-container"
              *ngIf="!options.hideConfirmButton">
              <button
                type="button"
                [mwlFocus]="options.focusButton === 'confirm'"
                [class]="'btn btn-block btn-' + options.confirmButtonType"
                (click)="options.onConfirm({clickEvent: $event})"
                [innerHtml]="options.confirmText">
              </button>
            </div>
          </div>
        </div>
      </div>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="options.customTemplate || defaultTemplate"
      [ngTemplateOutletContext]="{options: options}">
    </ng-template>
  `
            },] },
];
/** @nocollapse */
ConfirmationPopoverWindowComponent.ctorParameters = () => [
    { type: ConfirmationPopoverWindowOptions, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 * @record
 */

/**
 * All properties can be set on the directive as attributes like so (use `ConfirmationPopoverModule.forRoot()` to configure them globally):
 * ```html
 * <button
 *  class="btn btn-default"
 *  mwlConfirmationPopover
 *  [popoverTitle]="popoverTitle"
 *  [popoverMessage]="popoverMessage"
 *  placement="left"
 *  (confirm)="confirmClicked = true"
 *  (cancel)="cancelClicked = true"
 *  [(isOpen)]="isOpen">
 *   Show confirm popover!
 * </button>
 * ```
 */
class ConfirmationPopoverDirective {
    /**
     * \@internal
     * @param {?} viewContainerRef
     * @param {?} elm
     * @param {?} defaultOptions
     * @param {?} cfr
     * @param {?} position
     * @param {?} renderer
     */
    constructor(viewContainerRef, elm, defaultOptions, cfr, position, renderer) {
        this.viewContainerRef = viewContainerRef;
        this.elm = elm;
        this.defaultOptions = defaultOptions;
        this.cfr = cfr;
        this.position = position;
        this.renderer = renderer;
        /**
         * Whether to disable showing the popover. Default `false`.
         */
        this.isDisabled = false;
        /**
         * Will open or show the popover when changed.
         * Can be sugared with `isOpenChange` to emulate 2-way binding like so `[(isOpen)]="isOpen"`
         */
        this.isOpen = false;
        /**
         * Will emit when the popover is opened or closed
         */
        this.isOpenChange = new EventEmitter(true);
        /**
         * An expression that is called when the confirm button is clicked.
         */
        this.confirm = new EventEmitter();
        /**
         * An expression that is called when the cancel button is clicked.
         */
        this.cancel = new EventEmitter();
        this.eventListeners = [];
    }
    /**
     * \@internal
     * @return {?}
     */
    ngOnInit() {
        this.isOpenChange.emit(false);
    }
    /**
     * \@internal
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["isOpen"]) {
            if (changes["isOpen"].currentValue === true) {
                this.showPopover();
            }
            else {
                this.hidePopover();
            }
        }
    }
    /**
     * \@internal
     * @return {?}
     */
    ngOnDestroy() {
        this.hidePopover();
    }
    /**
     * \@internal
     * @param {?} event
     * @return {?}
     */
    onConfirm(event) {
        this.confirm.emit(event);
        this.hidePopover();
    }
    /**
     * \@internal
     * @param {?} event
     * @return {?}
     */
    onCancel(event) {
        this.cancel.emit(event);
        this.hidePopover();
    }
    /**
     * \@internal
     * @return {?}
     */
    togglePopover() {
        if (!this.popover) {
            this.showPopover();
        }
        else {
            this.hidePopover();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDocumentClick(event) {
        if (this.popover &&
            !this.elm.nativeElement.contains(event.target) &&
            !this.popover.location.nativeElement.contains(event.target)) {
            this.hidePopover();
        }
    }
    /**
     * @return {?}
     */
    showPopover() {
        if (!this.popover && !this.isDisabled) {
            // work around for https://github.com/mattlewis92/angular-confirmation-popover/issues/65
            // otherwise the document click event gets fired after the click event
            // that triggered the popover to open (no idea why this is so)
            setTimeout(() => {
                this.eventListeners = [
                    this.renderer.listen('document', 'click', (event) => this.onDocumentClick(event)),
                    this.renderer.listen('document', 'touchend', (event) => this.onDocumentClick(event)),
                    this.renderer.listen('window', 'resize', () => this.positionPopover())
                ];
            });
            const /** @type {?} */ options = new ConfirmationPopoverWindowOptions();
            Object.assign(options, this.defaultOptions, {
                popoverTitle: this.popoverTitle,
                popoverMessage: this.popoverMessage,
                onConfirm: (event) => {
                    this.onConfirm(event);
                },
                onCancel: (event) => {
                    this.onCancel(event);
                },
                onAfterViewInit: () => {
                    this.positionPopover();
                }
            });
            const /** @type {?} */ optionalParams = [
                'confirmText',
                'cancelText',
                'placement',
                'confirmButtonType',
                'cancelButtonType',
                'focusButton',
                'hideConfirmButton',
                'hideCancelButton',
                'popoverClass',
                'appendToBody',
                'customTemplate',
                'reverseButtonOrder'
            ];
            optionalParams.forEach(param => {
                if (typeof this[param] !== 'undefined') {
                    (/** @type {?} */ (options))[param] = this[param];
                }
            });
            const /** @type {?} */ componentFactory = this.cfr.resolveComponentFactory(ConfirmationPopoverWindowComponent);
            const /** @type {?} */ childInjector = Injector.create([
                {
                    provide: ConfirmationPopoverWindowOptions,
                    useValue: options
                }
            ], this.viewContainerRef.parentInjector);
            this.popover = this.viewContainerRef.createComponent(componentFactory, this.viewContainerRef.length, childInjector);
            if (options.appendToBody) {
                document.body.appendChild(this.popover.location.nativeElement);
            }
            this.isOpenChange.emit(true);
        }
    }
    /**
     * @return {?}
     */
    positionPopover() {
        if (this.popover) {
            const /** @type {?} */ popoverElement = this.popover.location.nativeElement.children[0];
            const /** @type {?} */ popoverPosition = this.position.positionElements(this.elm.nativeElement, popoverElement, this.placement || this.defaultOptions.placement, this.appendToBody || this.defaultOptions.appendToBody);
            this.renderer.setStyle(popoverElement, 'top', `${popoverPosition.top}px`);
            this.renderer.setStyle(popoverElement, 'left', `${popoverPosition.left}px`);
        }
    }
    /**
     * @return {?}
     */
    hidePopover() {
        if (this.popover) {
            this.popover.destroy();
            delete this.popover;
            this.isOpenChange.emit(false);
            this.eventListeners.forEach(fn => fn());
            this.eventListeners = [];
        }
    }
}
ConfirmationPopoverDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mwlConfirmationPopover]'
            },] },
];
/** @nocollapse */
ConfirmationPopoverDirective.ctorParameters = () => [
    { type: ViewContainerRef, },
    { type: ElementRef, },
    { type: ConfirmationPopoverOptions, },
    { type: ComponentFactoryResolver, },
    { type: Positioning, },
    { type: Renderer2, },
];
ConfirmationPopoverDirective.propDecorators = {
    "popoverTitle": [{ type: Input },],
    "popoverMessage": [{ type: Input },],
    "confirmText": [{ type: Input },],
    "cancelText": [{ type: Input },],
    "placement": [{ type: Input },],
    "confirmButtonType": [{ type: Input },],
    "cancelButtonType": [{ type: Input },],
    "focusButton": [{ type: Input },],
    "hideConfirmButton": [{ type: Input },],
    "hideCancelButton": [{ type: Input },],
    "isDisabled": [{ type: Input },],
    "isOpen": [{ type: Input },],
    "customTemplate": [{ type: Input },],
    "isOpenChange": [{ type: Output },],
    "confirm": [{ type: Output },],
    "cancel": [{ type: Output },],
    "popoverClass": [{ type: Input },],
    "appendToBody": [{ type: Input },],
    "reverseButtonOrder": [{ type: Input },],
    "togglePopover": [{ type: HostListener, args: ['click',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * A helper directive to focus buttons. You will only need this if using a custom template
 */
class FocusDirective {
    /**
     * @param {?} elm
     */
    constructor(elm) {
        this.elm = elm;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["mwlFocus"] && this.mwlFocus === true) {
            this.elm.nativeElement.focus();
        }
    }
}
FocusDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mwlFocus]'
            },] },
];
/** @nocollapse */
FocusDirective.ctorParameters = () => [
    { type: ElementRef, },
];
FocusDirective.propDecorators = {
    "mwlFocus": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const USER_OPTIONS = new InjectionToken('confirmation popover user options');
/**
 * @param {?} userOptions
 * @return {?}
 */
function optionsFactory(userOptions) {
    const /** @type {?} */ options = new ConfirmationPopoverOptions();
    Object.assign(options, userOptions);
    return options;
}
class ConfirmationPopoverModule {
    /**
     * @param {?=} options
     * @return {?}
     */
    static forRoot(options = {}) {
        return {
            ngModule: ConfirmationPopoverModule,
            providers: [
                {
                    provide: USER_OPTIONS,
                    useValue: options
                },
                {
                    provide: ConfirmationPopoverOptions,
                    useFactory: optionsFactory,
                    deps: [USER_OPTIONS]
                },
                Positioning
            ]
        };
    }
}
ConfirmationPopoverModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ConfirmationPopoverDirective,
                    ConfirmationPopoverWindowComponent,
                    FocusDirective
                ],
                imports: [CommonModule],
                exports: [ConfirmationPopoverDirective, FocusDirective],
                entryComponents: [ConfirmationPopoverWindowComponent]
            },] },
];
/** @nocollapse */
ConfirmationPopoverModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { ConfirmationPopoverModule, ConfirmationPopoverOptions as ɵd, ConfirmationPopoverWindowOptions as ɵf, ConfirmationPopoverWindowComponent as ɵe, ConfirmationPopoverDirective as ɵc, USER_OPTIONS as ɵa, optionsFactory as ɵb, FocusDirective as ɵg };
//# sourceMappingURL=angular-confirmation-popover.js.map
